<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-05-30T22:40:54+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Curious Libertine</title><subtitle>Personal Records of a philosophical libertine.</subtitle><author><name>jimin-mjl</name></author><entry><title type="html">Nginx와 Gunicorn 둘 중 하나만 써도 될까?</title><link href="http://localhost:4000/%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C/2021/04/26/wsgi-explained.html" rel="alternate" type="text/html" title="Nginx와 Gunicorn 둘 중 하나만 써도 될까?" /><published>2021-04-26T00:00:00+09:00</published><updated>2021-04-26T00:00:00+09:00</updated><id>http://localhost:4000/%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C/2021/04/26/wsgi-explained</id><content type="html" xml:base="http://localhost:4000/%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C/2021/04/26/wsgi-explained.html"><![CDATA[<p>Flask나 Django로 만든 파이썬 앱을 배포할 때, 보통 Nginx와 Gunicorn과 자기 앱을 연결해서 배포하는 게 정석처럼 여겨진다. 여기서 Nginx를 Apache로, Gunicorn을 uWSGI로 바꿔도 상관없다.</p>

<p>그런데 얘네가 뭐길래? 하는 의문이 든다. Nginx와 Apache는 웹 서버라는 이야기를 들어서 알겠다. 클라이언트의 요청을 받고 앱에 전달해서 앱의 response를 다시 클라이언트에게 전달해주는 역할이라는 것도 알겠다.</p>

<p>그러면 Gunicorn과 uWSGI는 뭐지? 얘네는 왜 있는 걸까? 없어도 되는 건가? 하는 생각이 들기 마련이다. 실제로 Gunicorn을 쓰지 않고 Nginx로만 배포한다는 소리도 들었다. 여기서 Gunicorn은 없어도 되지만 있으면 좋은 미들웨어구나, 하고 생각했다.</p>

<p>그런데 Nginx 없이 Gunicorn으로만 배포한다는 소리를 들었다.</p>

<p>???</p>

<p>웹 서버의 역할을 하는 Nginx가 없어도 가능한건가? 하는 생각이 들었다.  그래서 Nginx, Gunicorn이 도대체 무슨 일을 하는 애들이고, 파이썬 앱과 어떻게 연결되어서 동작하는 것인지 알아보고자 한다.</p>

<p>Nginx, gunicorn, Django가 모두 서버 역할을 하고 있기 때문에, 이렇게 나눠져 있는 서버의 계층 시스템과 WSGI라는 것에 대해 먼저 알아볼 필요가 있다.</p>

<h2 id="1-wsgi의-등장-배경">1. WSGI의 등장 배경</h2>

<h3 id="3계층-시스템과-cgi">3계층 시스템과 CGI</h3>

<p>3계층 서버 시스템에 대해 들어본 적 있을 것이다. DB 서버는 차치하고 웹 서버와 어플리케이션 서버만 살펴보자. 초기에는 웹 서버만 있었다. 하드웨어에 파일과 이미지를 저장해두었다가 클라이언트로부터 요청이 들어오면 요청한 파일을 화면에 띄워주는 형식이었다.</p>

<p>이런 방식은 빠르고 편했지만 Only Static, 정적인 파일밖에 건네줄 수가 없었다. 그런데 클라이언트로부터 오는 요청이 다양하고 복잡해지면서 로직으로 구현해야 하는 동적인 파일에 대한 요청이 생겨나게 되고, 이런 정적인 파일만으로는 한계를 느끼게 되었다.</p>

<p>그래서 등장한 게 <strong>웹 어플리케이션 서버</strong>이다. 데이터 파일을 저장해두는 대신, 소스 스크립트를 서버에 저장해놓고 요청이 올 때마다 스크립트를 실행시켜 결과를 반환해주는 것이다. 쉽게 말해 소스 스크립트가 있는 웹 앱 자체를 클라이언트의 요청을 받는 웹 서버로 사용하는 것이다.</p>

<p>그런데, 여기서 <strong>파이썬 스크립트가 어떻게 HTTP 요청을 받을 것인가</strong>, 하는 문제가 발생한다.</p>

<p>HTTP 요청은 기본적으로 <code class="language-plaintext highlighter-rouge">GET /home.html HTTP/1.1</code> 과 같은 텍스트이고, 이는 파이썬 앱이 받는 request object의 형식과는 다르기 때문이다.</p>

<p>그래서 클라이언트로부터 오는 HTTP 요청을 파이썬 스크립트가 요구하는 데이터 형식으로 변환하고 응답을 돌려줄 때도 파이썬 데이터를 HTTP 형식으로 바꿔주는 작업이 필요한데, 이 때 파이썬 앱 서버가 동작하는 기본적인 방식이 <strong>CGI, Common Gateway Interface</strong>이다.</p>

<p>즉, CGI란 파이썬 어플리케이션 서버의 동작 방식에 대한 specification(사양, 매뉴얼)이라고 할 수 있고 그 기본적인 동작 과정은 다음과 같다.</p>

<ul>
  <li>인풋으로 HTTP 요청을 받는다.</li>
  <li>요청에 대한 정보를 환경변수의 형식으로 만들어서 파이썬 스크립트의 stdin 형식의 인풋으로 받는다.</li>
  <li>스크립트가 print와 같은 stdout 형식으로 응답하면 HTTP 형식으로 변환된다.</li>
</ul>

<h3 id="wsgi의-등장">WSGI의 등장</h3>

<p>그런데 CGI는 한 가지 문제점이 있었는데, 바로 요청이 들어올 때마다 파이썬 스크립트를 처음부터 실행한다는 것이었다. 이렇게 되면 서버가 너무 느리고 효율도 좋지 않았다.</p>

<p>이 때 등장한 게 <strong>WSGI(Web Server Gateway Interface)</strong>이다. CGI처럼 WSGI 또한 웹 어플리케이션 서버의 동작 방식에 대한 specification인데, 기본적인 아이디어는 다음과 같다.</p>

<p>웹 서버와 파이썬 스크립트를 분리하고 웹 서버가 클라이언트의 요청을 받아서 스크립트에 전달해주면 스크립트는 스크립트 전체를 실행시키는 게 아니라 필요한 로직 하나만 실행한 후 결과를 응답해주는 식으로 동작함으로써 동적인 콘텐츠에 대한 요청에 빠르게 응답할 수 있게 한 것이다.</p>

<p>이러한 WSGI가 표준적인 파이썬 어플리케이션 서버의 동작 방식이 됨에 따라, WSGI 서버가 클라이언트의 요청을 받는 웹 서버의 역할을 하게 되고 WSGI compatible한 파이썬 앱이 WSGI 서버와 합쳐져서 웹 어플리케이션 서버가 되게 된다.
<img src="https://images.velog.io/images/jimin_lee/post/19d94186-29f9-4cf2-a9c3-0b9e7bb39086/KakaoTalk_20210425_212448657_01.jpg" alt="" /></p>

<p>즉, 여기서 WSGI 서버의 역할을 수행하는 애가 Gunicorn이고, Django는 파이썬 앱이라고 할 수 있으며, 얘네가 함께 웹 어플리케이션 서버가 되는 것이다. Nginx는 여기서 Gunicorn+Django의 앞단에 위치하고 있는데, WSGI의 프로세스와는 별 관련 없이 buffering, reverse proxy나 load balance와 같은 별도의 일을 수행하게 되는 것이다.</p>

<h2 id="2-wsgi의-동작-과정">2. WSGI의 동작 과정</h2>

<p>WSGI에 대해 좀 더 감을 잡기 위해 <a href="https://www.python.org/dev/peps/pep-0333/#specification-overview">PEP333</a>에 나와있는 WSGI의 동작 과정을 한 번 살펴보려고 한다. 다시 한 번 말하지만 WSGI는 별도의 프레임워크 같은 게 아니라, 동적인 데이터에 대응하기 위해서 웹 서버와 파이썬 웹 앱이 어떻게 서로 동작해야 하는지에 대한 내용을 담고 있는 specification이라고 할 수 있다.</p>

<p>공식 문서에서는 WSGI를 <strong>“simple and universal interface between web servers and web applications or frameworks”</strong>라고 설명하고 있으며, WSGI의 목적은 <strong>“to facilitate easy interconnection of existing servers and applications or frameworks, not to create a new web framework”</strong>라고 서술하고 있다.</p>

<p>WSGI는 server/gateway side와 application/framework side를 가지는데, server side에서 들어온 요청이 application side의 callable object를 호출(invoke)하게 된다. 여기서 callable object란 곧 파이썬 스크립트에서 정의한 application을 의미하고, object라고는 했지만 callable한 어떤 형태든지 상관은 없다.</p>

<p><img src="https://images.velog.io/images/jimin_lee/post/d5fd03ea-666a-4a0b-8a03-d574cd7a34f0/KakaoTalk_20210425_212448657.jpg" alt="" /></p>

<p>각각의 코드를 한 번 살펴보자.</p>

<h3 id="applicationframework-side">Application/Framework Side</h3>

<p>다음은 함수 형태의 application이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="s">"""Simplest possible application object"""</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s">'200 OK'</span>
    <span class="n">response_headers</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'Content-type'</span><span class="p">,</span> <span class="s">'text/plain'</span><span class="p">)]</span>
    <span class="n">start_response</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="s">'Hello world!</span><span class="se">\n</span><span class="s">'</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li>application은 environ 객체와 start_response라는 콜백함수를 인자로 받는다.</li>
  <li>environ은 method나 url 등 HTTP 요청에 대한 정보를 CGI 환경 변수의 형식으로 담고 있는 dictionary 형태의 객체라고 할 수 있다.</li>
  <li>start_response 콜백 함수는 status와 response_headers라는 두 가지 인자를 받는다.</li>
  <li>status에는 <code class="language-plaintext highlighter-rouge">200 OK</code> 와 같은 HTTP status 코드가 들어가고, response_headers에는 HTTP 헤더가 들어간다.</li>
</ul>

<h3 id="servergateway-side">Server/Gateway Side</h3>

<p>server side에서는 클라이언트의 요청이 올 때마다 application을 호출한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span><span class="p">,</span> <span class="n">sys</span>

<span class="k">def</span> <span class="nf">run_with_cgi</span><span class="p">(</span><span class="n">application</span><span class="p">):</span> <span class="c1"># application을 인자로 받음
</span>    <span class="c1"># environ 객체
</span>    <span class="n">environ</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">.</span><span class="n">items</span><span class="p">())</span>
    <span class="n">environ</span><span class="p">[</span><span class="s">'wsgi.input'</span><span class="p">]</span>        <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span>  <span class="c1"># stdin의 형태로 input을 받음
</span>    <span class="n">environ</span><span class="p">[</span><span class="s">'wsgi.errors'</span><span class="p">]</span>       <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stderr</span>
    <span class="n">environ</span><span class="p">[</span><span class="s">'wsgi.version'</span><span class="p">]</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">environ</span><span class="p">[</span><span class="s">'wsgi.multithread'</span><span class="p">]</span>  <span class="o">=</span> <span class="bp">False</span>
    <span class="n">environ</span><span class="p">[</span><span class="s">'wsgi.multiprocess'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">environ</span><span class="p">[</span><span class="s">'wsgi.run_once'</span><span class="p">]</span>     <span class="o">=</span> <span class="bp">True</span>

    <span class="k">if</span> <span class="n">environ</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'HTTPS'</span><span class="p">,</span> <span class="s">'off'</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="s">'on'</span><span class="p">,</span> <span class="s">'1'</span><span class="p">):</span>
        <span class="n">environ</span><span class="p">[</span><span class="s">'wsgi.url_scheme'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'https'</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">environ</span><span class="p">[</span><span class="s">'wsgi.url_scheme'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'http'</span>

    <span class="n">headers_set</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">headers_sent</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">headers_set</span><span class="p">:</span>
             <span class="k">raise</span> <span class="nb">AssertionError</span><span class="p">(</span><span class="s">"write() before start_response()"</span><span class="p">)</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">headers_sent</span><span class="p">:</span>
             <span class="c1"># Before the first output, send the stored headers
</span>             <span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span> <span class="o">=</span> <span class="n">headers_sent</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">headers_set</span>
             <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">'Status: %s</span><span class="se">\r\n</span><span class="s">'</span> <span class="o">%</span> <span class="n">status</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="n">response_headers</span><span class="p">:</span>
                 <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">'%s: %s</span><span class="se">\r\n</span><span class="s">'</span> <span class="o">%</span> <span class="n">header</span><span class="p">)</span>
             <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">'</span><span class="se">\r\n</span><span class="s">'</span><span class="p">)</span>

        <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="n">flush</span><span class="p">()</span>

		<span class="c1"># status와 response_headers를 받는 start_response 콜백함수 
</span>    <span class="k">def</span> <span class="nf">start_response</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">exc_info</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">headers_sent</span><span class="p">:</span>
                    <span class="c1"># Re-raise original exception if headers sent
</span>                    <span class="k">raise</span> <span class="n">exc_info</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exc_info</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">exc_info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">exc_info</span> <span class="o">=</span> <span class="bp">None</span>     <span class="c1"># avoid dangling circular ref
</span>        <span class="k">elif</span> <span class="n">headers_set</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">AssertionError</span><span class="p">(</span><span class="s">"Headers already set!"</span><span class="p">)</span>

        <span class="n">headers_set</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">write</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">:</span>    <span class="c1"># don't send headers until body appears
</span>                <span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">headers_sent</span><span class="p">:</span>
            <span class="n">write</span><span class="p">(</span><span class="s">''</span><span class="p">)</span>   <span class="c1"># send headers now if body was empty
</span>    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s">'close'</span><span class="p">):</span>
            <span class="n">result</span><span class="p">.</span><span class="n">close</span><span class="p">()</span> 
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">참고</code> <strong>WSGI Middleware</strong></p>

<ul>
  <li>WSGI server/gateway side와 application/framework side를 둘 다 구현하고 있는 하나의 프로그램</li>
  <li>서버에 대해서는 어플리케이션의 역할을 수행하고, 어플리케이션에 대해서는 서버의 역할을 수행.</li>
  <li>동작 과정 : 클라이언트 요청 → server side에서 middleware component를 호출 → middleware component가 application side의 application을 호출</li>
  <li><strong>Gunicorn, uWSGI</strong></li>
</ul>

<h2 id="3-framework의-wsgi-application">3. Framework의 WSGI application</h2>

<p>이번에는 대표적인 파이썬 프레임워크인 Django와 Flask에 내장된 WSGI application을 한 번 살펴보려고 한다.</p>

<h3 id="django">Django</h3>

<p>📁 django project를 생성하면 자동으로 만들어지는 wsgi.py 파일</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"""
WSGI config for movie_project project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.1/howto/deployment/wsgi/
"""</span>

<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">from</span> <span class="nn">django.core.wsgi</span> <span class="kn">import</span> <span class="n">get_wsgi_application</span>

<span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">'DJANGO_SETTINGS_MODULE'</span><span class="p">,</span> <span class="s">'movie_project.settings'</span><span class="p">)</span>

<span class="n">application</span> <span class="o">=</span> <span class="n">get_wsgi_application</span><span class="p">()</span>
</code></pre></div></div>

<p>📁 django.core.wsgi.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">django</span>
<span class="kn">from</span> <span class="nn">django.core.handlers.wsgi</span> <span class="kn">import</span> <span class="n">WSGIHandler</span>

<span class="k">def</span> <span class="nf">get_wsgi_application</span><span class="p">():</span>
    <span class="s">"""
    The public interface to Django's WSGI support. Return a WSGI callable.
    Avoids making django.core.handlers.WSGIHandler a public API, in case the
    internal WSGI implementation changes or moves in the future.
    """</span>
    <span class="n">django</span><span class="p">.</span><span class="n">setup</span><span class="p">(</span><span class="n">set_prefix</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">WSGIHandler</span><span class="p">()</span>
</code></pre></div></div>

<p>📁 django.core.handlers.wsgi.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">WSGIHandler</span><span class="p">(</span><span class="n">base</span><span class="p">.</span><span class="n">BaseHandler</span><span class="p">):</span>
    <span class="n">request_class</span> <span class="o">=</span> <span class="n">WSGIRequest</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">load_middleware</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
        <span class="n">set_script_prefix</span><span class="p">(</span><span class="n">get_script_name</span><span class="p">(</span><span class="n">environ</span><span class="p">))</span>
        <span class="n">signals</span><span class="p">.</span><span class="n">request_started</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">sender</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">environ</span><span class="o">=</span><span class="n">environ</span><span class="p">)</span>
        <span class="n">request</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">request_class</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_response</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

        <span class="n">response</span><span class="p">.</span><span class="n">_handler_class</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">__class__</span>

        <span class="n">status</span> <span class="o">=</span> <span class="s">'%d %s'</span> <span class="o">%</span> <span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">status_code</span><span class="p">,</span> <span class="n">response</span><span class="p">.</span><span class="n">reason_phrase</span><span class="p">)</span>
        <span class="n">response_headers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="o">*</span><span class="n">response</span><span class="p">.</span><span class="n">items</span><span class="p">(),</span>
            <span class="o">*</span><span class="p">((</span><span class="s">'Set-Cookie'</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">output</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="s">''</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">response</span><span class="p">.</span><span class="n">cookies</span><span class="p">.</span><span class="n">values</span><span class="p">()),</span>
        <span class="p">]</span>
        <span class="n">start_response</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="s">'file_to_stream'</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">environ</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'wsgi.file_wrapper'</span><span class="p">):</span>
            <span class="c1"># If `wsgi.file_wrapper` is used the WSGI server does not call
</span>            <span class="c1"># .close on the response, but on the file wrapper. Patch it to use
</span>            <span class="c1"># response.close instead which takes care of closing all files.
</span>            <span class="n">response</span><span class="p">.</span><span class="n">file_to_stream</span><span class="p">.</span><span class="n">close</span> <span class="o">=</span> <span class="n">response</span><span class="p">.</span><span class="n">close</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">environ</span><span class="p">[</span><span class="s">'wsgi.file_wrapper'</span><span class="p">](</span><span class="n">response</span><span class="p">.</span><span class="n">file_to_stream</span><span class="p">,</span> <span class="n">response</span><span class="p">.</span><span class="n">block_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">response</span>
</code></pre></div></div>

<h3 id="flask">Flask</h3>

<p>📁 flask app.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">"Hello World!"</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">app</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div></div>

<p>📁 flask.src.flask.app.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Flask</span><span class="p">(</span><span class="n">Scaffold</span><span class="p">):</span>
    <span class="s">"""The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the
    application.  Once it is created it will act as a central registry for
    the view functions, the URL rules, template configuration and much more.
    The name of the package is used to resolve resources from inside the
    package or the folder the module is contained in depending on if the
    package parameter resolves to an actual python package (a folder with
    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).
    """</span>

	<span class="k">def</span> <span class="nf">wsgi_app</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
	        <span class="s">"""The actual WSGI application. This is not implemented in
	        :meth:`__call__` so that middlewares can be applied without
	        losing a reference to the app object. Instead of doing this::
	            app = MyMiddleware(app)
	        It's a better idea to do this instead::
	            app.wsgi_app = MyMiddleware(app.wsgi_app)
	        Then you still have the original application object around and
	        can continue to call methods on it.
	        
	        :param environ: A WSGI environment. 
	        :param start_response: A callable accepting a status code,
	            a list of headers, and an optional exception context to
	            start the response.
	        """</span>
	        <span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
	        <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
	        <span class="k">try</span><span class="p">:</span>
	            <span class="k">try</span><span class="p">:</span>
	                <span class="n">ctx</span><span class="p">.</span><span class="n">push</span><span class="p">()</span>
	                <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">full_dispatch_request</span><span class="p">()</span>
	            <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
	                <span class="n">error</span> <span class="o">=</span> <span class="n">e</span>
	                <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">handle_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
	            <span class="k">except</span><span class="p">:</span>  <span class="c1"># noqa: B001
</span>	                <span class="n">error</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
	                <span class="k">raise</span>
	            <span class="k">return</span> <span class="n">response</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
	        <span class="k">finally</span><span class="p">:</span>
	            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">should_ignore_error</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
	                <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
	            <span class="n">ctx</span><span class="p">.</span><span class="n">auto_pop</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
	
        <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
            <span class="s">"""The WSGI server calls the Flask application object as the
            WSGI application. This calls :meth:`wsgi_app`, which can be
            wrapped to apply middleware.
            """</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">wsgi_app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="4-정리">4. 정리</h2>

<p>✔ <strong>Gunicorn은 왜 필요한가?</strong> 웹 앱에 HTTP 요청을 전달하고 응답을 되돌려주는 일을 할 WSGI server의 역할을 하기 위해서 → WSGI middleware</p>

<p>✔ <strong>Nginx는 왜 필요한가?</strong> reverse proxy server, load balancer 등의 역할을 수행하기 위해서</p>

<p>✔ <strong>Django/Flask는 왜 필요한가?</strong> WSGI compatible server를 알아서 제공해주기 때문이다. raw WSGI application을 만들 수는 있지만 기능을 일일이 다 구현하기 번거롭고 너무 많은 코너 케이스가 존재하기 때문에 권장하지는 않는다.  그래서 이미  session이나 cookie와 같은 많은 부분이 구현되어 있는 프레임워크를 쓰는 것이다.</p>

<p>✔ <strong>그럼 그냥 프레임워크 서버를 웹 서버로 사용하면 되지 않을까?</strong> 그래도 안될 건 없다. 하지만 보통은 그러지 않는다. 프레임워크가 제공하는 development server는 실제 트래픽에 대응할 수 없고 여러 부분에서 빈약하기 때문이다. Flask 앱을 만들 때 <code class="language-plaintext highlighter-rouge">flask run</code>을 통해 서버를 실행시키면 터미널에 production server용으로는 쓰지 말라는 메세지가 나오는 이유도 이 때문이다.</p>

<h2 id="그래서-결론은">그래서 결론은?</h2>

<p>✅ <strong>Gunicorn만 써도 돼?</strong> YES.</p>

<p>Gunicorn이 WSGI middleware로서 웹 서버의 역할을 수행하기 때문에 Gunicorn만 써도 된다. 다만, Nginx가 제공하는 추가적인 혜택을 받지 못할 뿐이다.</p>

<p>✅ <strong>Nginx만 써도 돼?</strong>  YES.</p>

<p>Flask나 Django 같은 프레임워크는 WSGI interface를 이미 어느 정도 구현해놓았기 때문에 프레임워크를 사용한다면 Nginx만 써도 된다. 다만 session, cookie, routing, authentication 등의 기능을 수행해주는 middleware의 역할을 하는 애가 없기 때문에 이 부분은 자기가 하드 코딩해야 한다. 결국, Gunicorn/uWSGI를 사용하는 것도 편리한 기능들을 제공해주는 라이브러리를 가져다 쓰는 것과 똑같다고 할 수 있고, 반드시 써야만 하는 건 아니다.</p>

<hr />
<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://youtu.be/WqrCnVAkLIo">https://youtu.be/WqrCnVAkLIo</a></li>
  <li><a href="https://youtu.be/H6Q3l11fjU0">https://youtu.be/H6Q3l11fjU0</a></li>
  <li><a href="https://www.python.org/dev/peps/pep-0333/#specification-overview">https://www.python.org/dev/peps/pep-0333/#specification-overview</a> (PEP333)</li>
  <li><a href="https://www.nginx.com/resources/glossary/application-server-vs-web-server/">https://www.nginx.com/resources/glossary/application-server-vs-web-server/</a></li>
  <li><a href="https://www.fullstackpython.com/green-unicorn-gunicorn.html#:~:text=Gunicorn%20is%20based%20on%20a,is%20independent%20of%20the%20controller">https://www.fullstackpython.com/green-unicorn-gunicorn.html#:~:text=Gunicorn is based on a,is independent of the controller</a>.</li>
  <li><a href="https://sgc109.github.io/2020/08/15/python-wsgi/">https://sgc109.github.io/2020/08/15/python-wsgi/</a></li>
  <li><a href="http://xplordat.com/2020/02/16/a-flask-full-of-whiskey-wsgi/">http://xplordat.com/2020/02/16/a-flask-full-of-whiskey-wsgi/</a></li>
</ul>

<h3 id="더-알아보고-싶은-내용">더 알아보고 싶은 내용</h3>

<ul>
  <li>ASGI : <a href="https://youtu.be/uRcnaI8Hnzg">https://youtu.be/uRcnaI8Hnzg</a></li>
</ul>]]></content><author><name>[&quot;jimin-mjl&quot;]</name></author><category term="서버개발" /><category term="nginx" /><category term="gunicorn" /><summary type="html"><![CDATA[Flask나 Django로 만든 파이썬 앱을 배포할 때, 보통 Nginx와 Gunicorn과 자기 앱을 연결해서 배포하는 게 정석처럼 여겨진다. 여기서 Nginx를 Apache로, Gunicorn을 uWSGI로 바꿔도 상관없다.]]></summary></entry><entry><title type="html">Nginx와 Gunicorn으로 Flask앱 배포하기</title><link href="http://localhost:4000/%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C/2021/02/08/deploying-flask-app.html" rel="alternate" type="text/html" title="Nginx와 Gunicorn으로 Flask앱 배포하기" /><published>2021-02-08T00:00:00+09:00</published><updated>2021-02-08T00:00:00+09:00</updated><id>http://localhost:4000/%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C/2021/02/08/deploying-flask-app</id><content type="html" xml:base="http://localhost:4000/%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C/2021/02/08/deploying-flask-app.html"><![CDATA[<h2 id="1-참고-자료">1. 참고 자료</h2>
<ul>
  <li><a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04">nginx 설치</a></li>
  <li><a href="https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-gunicorn-and-nginx-on-ubuntu-18-04">gunicorn 설치 및 nginx와 연결</a></li>
  <li><a href="https://youtu.be/kDRRtPO0YPA">우분투 서버에서 flask앱 배포하기</a></li>
</ul>

<p>처음에 세 번째의 영상을 보고 따라했는데, 연결이 잘 되는 것을 확인했지만 gunicorn에서 빠져나왔을 때 서버가 멈춘다. 내가 원하는 건 계속 돌아가게 하는 거였기 때문에 이 영상을 통해서는 연결이 잘 되는지 확인한 다음, 위의 두 글을 통해 이후의 단계를 진행했다.</p>

<hr />
<h2 id="2-들어가기-전에">2. 들어가기 전에</h2>
<p>처음에는 nginx와 uwsgi를 사용하려고 했는데, uwsgi를 설치하는데 계속 에러가 나서 gunicorn으로 시도해보았다. (uwsgi는 어떻게 읽는 걸까?)</p>

<p>모르는 게 너무 많아서 아직 이해를 다 못한 부분도 많지만 일단 이해한 만큼 적어보았다.</p>
<h3 id="2-1-wsgi란">2-1. WSGI란?</h3>
<p>CGI(Common Gateway Interface)의 일종으로, 프레임워크의 웹 서버이다.</p>

<p>WSGI에는 두 종류가 있다.</p>
<ul>
  <li>web server : Nginx, Apache</li>
  <li>web app : 파이썬 스크립트 파일</li>
</ul>

<p>그럼 Gunicorn, uWSGI은? web server와 web app의 middleware라고 할 수 있다.</p>

<p>정리하자면 이런 식이다.</p>
<ul>
  <li>내가 만든 앱 : flask app</li>
  <li>웹 서버 : nginx</li>
  <li>앱과 웹 서버를 연결하는 미들웨어: gunicorn</li>
</ul>

<h4 id="참고-글"><a href="https://paphopu.tistory.com/entry/WSGI%EC%97%90-%EB%8C%80%ED%95%9C-%EC%84%A4%EB%AA%85-WSGI%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">참고 글</a></h4>

<h3 id="2-2-전체-프로세스">2-2. 전체 프로세스</h3>
<blockquote>
  <p>client request -&gt; nginx : web proxy server -&gt; gunicorn : application server -&gt; flask app</p>
</blockquote>

<p>서버가 응답할 때는 요청 받은 순서 반대로 수행한다. 
참고로 proxy server는  클라이언트와 서버를 중계하는 서버이다.</p>

<hr />
<h2 id="3-nginx">3. Nginx</h2>
<h3 id="3-1-nginx-설치하기">3-1. Nginx 설치하기</h3>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update 
<span class="nb">sudo </span>apt <span class="nb">install </span>nginx 
</code></pre></div></div>
<h3 id="3-2-방화벽-설정하기">3-2. 방화벽 설정하기</h3>
<p>nginx의 접근을 허용하기 위해 방화벽 설정부터 해줘야 한다. 
우선 <code class="language-plaintext highlighter-rouge">sudo ufw app list</code> 를 통해 설정 가능한 방화벽을 확인하면 다음과 같이 나온다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Available applications:
  Nginx Full    // HTTP, HTTPS 모두 허용
  Nginx HTTP    // HTTP만 허용
  Nginx HTTPS   // HTTPS만 허용
  OpenSSH
</code></pre></div></div>
<p>설정은 <code class="language-plaintext highlighter-rouge">sudo ufw allow 'Nginx HTTP'</code> 를 통해 가능하고,
<code class="language-plaintext highlighter-rouge">sudo ufw status</code> 를 통해 확인할 수 있다.</p>
<h3 id="3-3-웹-서버-확인하기">3-3. 웹 서버 확인하기</h3>
<p>nginx가 설치되면 자동으로 실행된다. 
상태를 확인하고 싶다면 <code class="language-plaintext highlighter-rouge">systemctl status nginx</code> 로 가능하다.</p>

<p>그런데, 내 경우에는 이게 inactive 상태였다. 
그래서 <code class="language-plaintext highlighter-rouge">sudo ufw enable</code> 을 추가적으로 입력해서 active상태로 만들었다.</p>
<h3 id="3-4-부록--nginx-상태-관련-명령어-정리">3-4. 부록 : Nginx 상태 관련 명령어 정리</h3>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl start nginx   // nginx 시작
<span class="nb">sudo </span>systemctl stop nginx   // nginx 멈추기
<span class="nb">sudo </span>systemctl restart nginx   // nginx 재시작<span class="o">(</span>멈추고 다시 시작<span class="o">)</span>
<span class="nb">sudo </span>systemctl reload nginx   // 설정 파일만 수정했을 경우 연결을 끊지 않고 수정사항 적용시키기
<span class="nb">sudo </span>systemctl disable nginx   // nginx는 서버가 부팅되면 자동으로 시작된다. 이 설정을 지우기
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>nginx   // 위의 설정을 다시 <span class="nb">enable </span>시키기
</code></pre></div></div>
<hr />
<h2 id="4-gunicorn">4. Gunicorn</h2>
<h3 id="4-1-설치-전에-의존-패키지-설치하기">4-1. 설치 전에 의존 패키지 설치하기</h3>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install </span>python3-pip python3-dev build-essential libssl-dev libffi-dev python3-setuptools
</code></pre></div></div>
<h3 id="4-2-가상환경-설치하고-접속하기">4-2. 가상환경 설치하고 접속하기</h3>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>python3-venv
python3 <span class="nt">-m</span> venv venv-name
<span class="nb">source </span>venv-name/bin/activate
</code></pre></div></div>
<p>이제 가상환경 안에서 작업한다.</p>
<h3 id="4-3-gunicorn-설치하기">4-3. Gunicorn 설치하기</h3>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>wheel // package에 wheel archive가 없어도 설치되게끔 하기 위해서라는데 일단 설치한다. 
pip <span class="nb">install </span>gunicorn flask
which gunicorn // gunicorn 경로 확인하기
</code></pre></div></div>
<p>wheel 같은 경우는 uwsgi를 설치하려고 했을 때 uwsgi를 위한 wheel이 없다는 에러 메세지가 계속 뜨던데 그런 걸 말하는 것 같다.</p>
<h3 id="4-4-entry-point-파일-만들기">4-4. Entry Point 파일 만들기</h3>
<p>app을 import한 wsgi.py 파일을 만들어줬다. app.py를 그냥 entry point로 써도 되지 않을까 싶어서 처음에는 따로 만들지 않았는데 나중에 에러가 나서 찾아보다가 django는 wsgi.py파일을 찾아본다는 소리를 들었다. 근데 이건 flask 앱인데 이 문제가 맞을까 싶었지만 혹시 모르니까 일단 만들어줬다.</p>

<p>만들고 나서 실행되는지 체크해보기 : <code class="language-plaintext highlighter-rouge">gunicorn wsgi:app</code>
wsgi는 파일 이름이고 app은 app 이름이다.</p>

<h3 id="4-5-service-파일-만들기">4-5. service 파일 만들기</h3>
<p>가상환경에서 빠져나와서 작업한다. 
빠져나오는 명령어는 <code class="language-plaintext highlighter-rouge">deactivate</code>.</p>
<h4 id="1-etcsystemdsystem-디렉토리-안에-etcsystemdsystemmyflaskservice-파일을-만들어준다">1) /etc/systemd/system/ 디렉토리 안에 /etc/systemd/system/myflask.service 파일을 만들어준다.</h4>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nano /etc/systemd/system/myproject.service   // 참고로 etc 앞에 /가 안붙으면 새로운 파일일 경우 알아서 만들어주지 않으니 붙여준다.
</code></pre></div></div>
<p>파일 이름은 아무거나 해도 상관없지만 되도록 다른 파일 이름이나 디렉토리 이름이랑 통일시켜주자…! 헷갈려 죽겠다.
여기서는 구분을 위해 파일 이름은 myflask, 프로젝트 디렉토리 이름은 myproject, 유저 이름은 userme로 했다.</p>

<h4 id="2-다음의-내용을-작성한다">2) 다음의 내용을 작성한다.</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Unit]
Description=Gunicorn instance to serve myflask
After=network.target

[Service]
User=userme
Group=www-data
WorkingDirectory=/home/userme/myproject
Environment="PATH=/home/userme/myproject/myproject-env/bin"
ExecStart=/home/userme/myproject/myproject-env/bin/gunicorn --workers 3 --bind unix:myflask.sock -m 007 wsgi:app

[Install]
WantedBy=multi-user.target
</code></pre></div></div>
<p>unix:myflask.sock 부분이 nginx와 연결될 socket 파일이다.</p>
<h4 id="3-service-파일-실행시키고-상태-확인하기">3) service 파일 실행시키고 상태 확인하기</h4>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl start myflask
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>myflask
<span class="nb">sudo </span>systemctl status myflask
</code></pre></div></div>
<h4 id="4-오류-해결하기">4) 오류 해결하기</h4>
<p>위의 예시 그대로 했더니 상태가 failed(result:exit-code) 로 뜨길래,
service 파일의 <code class="language-plaintext highlighter-rouge">ExecStart= --workers 3</code> 
이 부분을 <code class="language-plaintext highlighter-rouge">--workers 1</code> 으로 바꿔준 다음,
<code class="language-plaintext highlighter-rouge">sudo systemctl restart myflask</code> 로 재시작했더니 잘 작동하는 것을 확인했다.</p>

<hr />

<h2 id="5-gunicorn을-nginx와-연결시키기">5. Gunicorn을 Nginx와 연결시키기</h2>
<h3 id="5-1-들어가기-전에">5-1. 들어가기 전에</h3>
<p>우선 nginx의 디렉토리 구조를 이해할 필요가 있다.
나도 자세히는 이해하지 못했기 때문에 우선 이해한 만큼만 적어본다.
여기서는 두 개만 알면 된다.</p>
<ul>
  <li>/etc/nginx/sites-available/ : 여기서 설정 파일을 만들어서 수정한다.</li>
  <li>/etc/nginx/sites-enabled/ : sited-available 디렉토리의 설정 파일이 이 디렉토리의 파일과 link되어 nginx에 적용된다.</li>
</ul>

<p>정리하자면, 설정파일을 우리가 생성하고 수정할 때는 sites-available에 있는 파일을 건드리고 sites-enabled의 파일은 직접 건드리지 않는다.
그런데 nginx는 sites-enabled를 찾아보지 sites-available을 찾아보지 않는다.
그래서 sites-available에서 수정한 파일을 sites-enable의 파일과 링크시켜서 수정 사항이 반영되도록 한다.
(그런데 참고한 영상에서는 바로 sites-enabled의 파일을 수정하던데 별 상관 없는건가 싶기도 하다)</p>

<h3 id="5-2-nginx의-설정-파일-생성하기">5-2. nginx의 설정 파일 생성하기</h3>
<p>/etc/nginx/sites-available/에 새 설정 파일을 만들어준다.</p>
<h4 id="a-기존의-파일default을-삭제하고-내-것myflask으로-다시-만들어준다">a. 기존의 파일(default)을 삭제하고 내 것(myflask)으로 다시 만들어준다.</h4>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo rm</span> /etc/nginx/sites-available/default
<span class="nb">sudo rm</span> /etc/nginx/sites-enabled/default
<span class="nb">sudo touch</span> /etc/nginx/sites-available/myflask
</code></pre></div></div>
<h4 id="b-에디터로-열어서-다음의-내용을-작성하고-저장한다">b. 에디터로 열어서 다음의 내용을 작성하고 저장한다.</h4>
<p><code class="language-plaintext highlighter-rouge">sudo nano /etc/nginx/sites-available/myflask</code> 로 파일을 열어준다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
	listen 80 default_server;
	listen [::]:80 default_server;
	server_name 0.0.0.0;
	location / {
		include proxy_params;
		proxy_pass http://unix:/home/sammy/myproject/myproject.sock; // gunicorn service 파일에서 socket 파일의 경로
	}
}
</code></pre></div></div>
<p>내 경우 proxy_pass는 <code class="language-plaintext highlighter-rouge">http://unix:/home/userme/myproject/myflask.sock</code> 이다.</p>
<h3 id="5-3-sites-available의-파일과-sites-enabled의-파일을-연결시키기">5-3. sites-available의 파일과 sites-enabled의 파일을 연결시키기</h3>
<p>두 디렉토리의 서로 다른 파일 사이에 심볼릭 링크를 생성해서 연결시키는 작업을 해준다.</p>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo ln</span> <span class="nt">-s</span> /etc/nginx/sites-available/myflask /etc/nginx/sites-enabled/myflask    
</code></pre></div></div>
<p>ln : link, -s : symbolic</p>
<h3 id="5-4-마무리-작업">5-4. 마무리 작업</h3>
<p>마지막으로 해당 설정 파일에 문법 오류가 없는지 체크하고, 아무 문제가 없으면 nginx를 재시작한다.</p>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nginx <span class="nt">-t</span>  // 문법 오류 체크
<span class="nb">sudo </span>systemctl restart nginx
</code></pre></div></div>
<h3 id="5-5-접속해서-확인하기">5-5. 접속해서 확인하기</h3>
<p>이제 원격 IP 주소로 접속해서 잘 뜨는지 확인하면 끝!</p>
<h3 id="5-6-정상-작동하지-않는다면">5-6. 정상 작동하지 않는다면</h3>
<p>만약 여기서 잘 안되면 방화벽을 확인해보자. 가상머신의 네트워킹도 확인해보면서 이것저것 시도해보자!</p>
<div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>ufw app list
<span class="nb">sudo </span>ufw allow <span class="s1">'Nginx Full'</span>  // HTTP, HTTPS 모두 접근 허용
<span class="nb">sudo </span>ufw status
</code></pre></div></div>]]></content><author><name>[&quot;jimin-mjl&quot;]</name></author><category term="서버개발" /><category term="nginx" /><category term="gunicorn" /><category term="flask" /><summary type="html"><![CDATA[1. 참고 자료 nginx 설치 gunicorn 설치 및 nginx와 연결 우분투 서버에서 flask앱 배포하기]]></summary></entry></feed>